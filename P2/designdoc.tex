\documentclass[10pt]{article}

\usepackage{fullpage}
\usepackage{graphicx}
\newcommand{\diagram}[2][1]{\begin{center}\includegraphics[width=#1\textwidth]{#2}\end{center}}
\graphicspath{ {images/} }
\usepackage[normalem]{ulem} % For strikethrough font
\title{Design Documentation}
% Name, netid
\author{Samuel Thomas (sgt43) \and Elisha Sword (eds88)}


\begin{document}
\maketitle

\section{Introduction}
The purpose of this document is to communicate the design of our 5-stage pipelined MIPS processor. 
We go into detail of the design of each of the five stages in the pipeline as well as the pipeline registers that connect the stages.
This document assumes knowledge of MIPS and of logic gates. It is not meant to be instructive in these regards. 

A pipelined processor is a processor that executes each instruction by passing it through different stages. At the end of each stage, the results are stored.
At the beginning of each stage, the stage grabs the output from the previous stages. Although pipelining increases the number of clock cycles
that it takes to execute each instruction, we can reduce the clock speed and increase the throughput of our processor.

\section{Overview}
We present a 5-staged pipeline design. Instructions are fetched in the first stage. Instructions are decoded and registers are read in the second stage.
The third stage executes an instruction. The fourth stage writes values to memory if required.
The fifth stage writes the results of the execute stage back into the register file.

\section{Instruction Fetch Stage}
This stage fetches the next instruction to execute. We store all of the instructions in Program ROM and keep track of where we are in the execution with \texttt{PC}.
Every clock cycle the \texttt{PC} is incremented.

\subsection{Circuit Diagram}
\diagram[0.8]{fetch}
\subsubsection{PC Incrementer}
We store the \texttt{PC} in a 32-bit register. Every clock cycle, we increment the upper 30 bits by 1 with a \texttt{+1 Incrementer} without touching the lower 2 bits.
This gives us the desired effect of advancing the program counter by four every clock cycle.
The \texttt{en} input is an on/off switch. When turned off, it resets the counter. 
\subsubsection{Latch}
We will store the fetched instruction in the latch at the end of this stage. We are not supporting jump instructions so we do not store \texttt{PC+4}.

\subsection{Correctness Constraints}
Fetch the next instruction on the rising edge of the clock cycle. 
\begin{itemize}
\item Correctly increment \texttt{PC} by 4 every clock cycle.
\end{itemize}

\subsection{Testing}
Test that the instructions are fetched in the correct order.

\section{Instruction Decoding Stage}
This is the stage where our register file lives. In the first half of the clock cycle, we write input \texttt{W} to register \texttt{rW} if \texttt{wE} is high. 
In the second half of the clock cycle, we read registers \texttt{rA} and registers \texttt{rB} and output them as \texttt{A} and \texttt{B} respectively.
We also split the opcode into \texttt{rd}, \texttt{shamt}, \texttt{fcn}, and \texttt{imm} so that future stages simpler. 
\subsection{Circuit Diagram}
\diagram[0.8]{decode}
\subsubsection{Outputs}
\begin{itemize}
\item \texttt{A} and \texttt{B} are read from the register file based on \texttt{rA} (bits 21-25) and \texttt{rB} (bits 16-20).
\item The output \texttt{rd} is determined by \texttt{bit 3} of the opcode. When this bit is low, \texttt{rd = bits 11-15}. When this bit is high, \texttt{rd = bits 16-20}.
\item \texttt{shamt} is always equal to \texttt{bits 6-10}.
\item \texttt{fcn} is a 7-bit number that will be used in the execute stage to determine what operation to give to the ALU.
  The lower 6-bits of this number from either the opcode \texttt{bits 0-5} or, if the opcode is all 0s, from \texttt{bits 26-31}.
  The upper bit of \texttt{fcn} is 0 if the opcode is all 0s and 1 otherwise.
\item \texttt{imm} is \texttt{bits 0-15} (either sign extended or zero extended depending on \texttt{bit 2} of the \texttt{fcn} part of the instruction),
  or \texttt{bits 6-10} zero extended. This is determined by \texttt{bit 3} of the opcode.
  The purpose of this is to have a 32-bit zero to compare against in the execute stage.
\end{itemize}

\subsection{Correctness Constraints}
\begin{itemize}
\item \texttt{W} is correctly written to \texttt{rW} in the first half of the stage. 
\item \texttt{A} and \texttt{B} are correctly read from the registers based on \texttt{rA} and \texttt{rB}.
\item \texttt{rD} is correctly chosen based on the instruction. 
\item \texttt{shamt} is fetched correctly from the instruction.
\item \texttt{fcn} correctly chooses between the opcode and the special function portion of the instruction.
\item \texttt{imm} correctly outputs sign-extended lower 16-bits, zero-extended lower 16-bits, and 32-bit zero.
\end{itemize}
\subsection{Testing}
Test vectors will be written to test each possible opcode to see if the above conditions are true.
To test if the values are correctly written in the first half of the stage, we will write a value to a register and attempt to output the value from the same register. 
\section{Execute Stage}
This stage executes all of the instructions that we will implement in this project. 
\subsection{Circuit Diagram}
\diagram{execute}
There are two executing subcircuits (\texttt{comp} and \texttt{ALU}) and one logic subcircuit (\texttt{parser}).
\texttt{Comp} performs comparison operations for \texttt{SLT}, \texttt{SLTU}, \texttt{SLTI}, \texttt{SLTIU}, \texttt{MOVN}, and \texttt{MOVZ}.
\texttt{ALU} performs all of the other arithmetic operations.
\texttt{parser} parses the \texttt{fcn} input into an opcode for the ALU as well as other control logic that chooses between different outputs.
\subsubsection{Comp}
\diagram[0.7]{comp}
This circuit uses an unsigned and signed comparator to perform $A < B$.
We also use the comparators to perform $A = B$. An \texttt{XOR} gate is used to invert this when \texttt{bit 0} is high.
\texttt{Bit 0} of \texttt{ctrl} also switches between signed and unsigned.
\subsubsection{Parser}
All the bits referenced below refer to bits of \texttt{fcn}.
\begin{itemize}
\item \texttt{Bit 0-2} determine the 3 upper bits of the ALU opcode. The lowest bit is always 0.
\item \texttt{Bit 6} chooses whether or not to replace \texttt{B} with an immediate. We choose an immediate with \texttt{Bit 6} is high.
  The one exception to this is when we are performing \texttt{MOV} instructions. In this case, we also want to replace \texttt{B} with an immediate (which will always be 0).
\item If \texttt{Bit 0-3} are all high, then we are performing \texttt{LUI}. Here we replace the output of the \texttt{ALU}
  with \texttt{imm} shifted left by 16.
\item Finally, we always want to output \texttt{we} except when \texttt{MOVN} or \texttt{MOVZ} return false.
\end{itemize}
\subsection{Correctness Constraints}
\begin{itemize}
\item \texttt{we} should be on for all instructions except when \texttt{MOVN} or \texttt{MOVZ} return false.
\item Addition, Subtraction, Shifting, Logic operations, Comparison operations should all execute as expected. 
\end{itemize}
\subsection{Testing}
We will write text vectors to test all valid inputs to see if the circuit outputs the correct results.
\section{Memory Stage}
In this project, this stage doesn't do anything. It simply forwards it's inputs to the next stage. 
\subsection{Circuit Diagram}
\diagram[0.5]{memory}
\section{Write-Back Stage}
For this project, there is no logic in this stage. It simply pipes \texttt{D}, \texttt{rd}, and \texttt{we} back to the decode subcircuit where it is written to the register file.
\subsection{Circuit Diagram}
\diagram[0.7]{writeback}
This diagram shows more than just the writeback. For this project, the writeback stage simply consists of wires.
For the next project, we will need to add logic to chose whether to write \texttt{D} or \texttt{M} to the register file.
\subsection{Pipeline Registers}
In between each stage, there is a pipeline register. These simply contain a register for each input that are written to on the rising edge of the clock.
Below is the implementation of the execute-memory pipeline register. All of the others are implemented in a similar fashion.
\diagram[0.6]{pipeline}
\section{Summary}
In this document, we presented a design for a limited 5-stage pipelined MIPS processor. Such a design greatly increases the performance of our processor by
allowing multiple instructions to be executed simultaneously.

\end{document}
